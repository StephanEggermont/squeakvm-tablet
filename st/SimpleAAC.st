AlignmentMorph subclass: #AACImageSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AACImageSpace methodsFor: 'drawing' stamp: 'DMG 3/29/2011 20:50'!drawOn: aCanvas	"draw a leftwards triangle at my right side taking 10% of width"	| mdpx mdpy cxctr cxlx cxty cxrx cxby cxsz |	super drawOn: aCanvas.	mdpx := self bottomRight x - (self width * 0.1).	mdpy := self bottomRight y - (self height * 0.5).	cxsz := self width * 0.015.	cxctr := (mdpx + (cxsz * 4))@mdpy.	cxlx := cxctr x - cxsz.	cxty := cxctr y + cxsz.	cxrx := cxctr x + cxsz.	cxby := cxctr y - cxsz.	aCanvas drawPolygon: {self bottomRight. 									mdpx@mdpy. 									self topRight}				color: self defaultColor darker darker darker				borderWidth: 1				borderColor: Color gray.	aCanvas line: cxlx@cxty				to: cxrx@cxby				width: 4				color: self defaultColor.	aCanvas line: cxrx@cxty				to: cxlx@cxby				width: 4				color: self defaultColor.! !Morph subclass: #AACPanel	instanceVariableNames: 'locked ptop up panels nmorphs imgside nrows ncols svbnds mxmd'	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AACPanel methodsFor: 'event handling' stamp: 'DMG 5/18/2011 23:08'!addedMorph: aMorph	"once a morph has been added, resize it to the stored image size per better	 layout".	super addedMorph: aMorph.	(aMorph respondsTo: #image) & (aMorph respondsTo: #image: ) ifTrue: [		aMorph image: (aMorph image scaledToSize: imgside@imgside).	].	self layoutChanged.! !!AACPanel methodsFor: 'event handling' stamp: 'DMG 5/4/2011 22:25'!handlesMouseDown: anEvent  "always handle mouse events"  ^ true.! !!AACPanel methodsFor: 'event handling' stamp: 'DMG 5/18/2011 21:23'!mouseDown: anEvent	"on red mouse click add a new (blank) AACImageMorph unless locked.	 on yellow mouse click toggle the locked flag"	anEvent redButtonPressed ifTrue: [		self newMorph.		^ true.	].	anEvent yellowButtonPressed ifTrue: [		^ super mouseDown: anEvent.	].	^ false.! !!AACPanel methodsFor: 'event handling' stamp: 'DMG 5/17/2011 20:39'!mouseDownOld: anEvent	"on red mouse click add a new (blank) AACImageMorph unless locked.	 on yellow mouse click toggle the locked flag"	anEvent redButtonPressed ifTrue: [		locked ifFalse: [			nmorphs := nmorphs + 1.			self recalcImageSize.			self addMorphBack: AACImageMorph new.		].		^ true.	].	anEvent yellowButtonPressed ifTrue: [		locked := locked not.		locked 	ifTrue: [self color: Color lightBlue] 					ifFalse: [self color: Color lightGreen].	].	^ false.! !!AACPanel methodsFor: 'creation' stamp: 'DMG 5/8/2011 23:08'!panel: aKey	"Answer a panel with given name. If the panel does not exist it is created.	 New panel becomes visible, current panel (caller) becomes invisible.	 Special names top and up always result in up panel and top panel."	| np |	np := nil.	aKey = #top ifTrue: [ np := ptop ].	aKey = #up ifTrue: [ np := up ].	np ifNil: [		panels at: aKey ifAbsent: [			| p |			p := AACPanel new.			panels at: aKey put: p.			p 	up: self ;				ptop: ptop ;				openInWorld.		].		np := panels at: aKey.	].	np bounds: (ptop bounds).	np = self ifFalse: [		self visible: false.		np visible: true.	].	^ np.! !!AACPanel methodsFor: 'creation' stamp: 'DMG 5/8/2011 23:08'!ptop: aPanel	ptop := aPanel.! !!AACPanel methodsFor: 'creation' stamp: 'DMG 5/8/2011 22:55'!up: aPanel	up := aPanel.! !!AACPanel methodsFor: 'submorphs-add/remove' stamp: 'DMG 5/18/2011 06:22'!newMorph	(nmorphs < (ncols * nrows)) ifTrue: [			nmorphs := nmorphs + 1.			self addMorphBack: AACImageMorph new replaceFromFileMenu.	].! !!AACPanel methodsFor: 'submorphs-add/remove' stamp: 'DMG 5/18/2011 21:48'!removeAll	self submorphsDo: [ :m | m delete. ].	nmorphs := 0.! !!AACPanel methodsFor: 'submorphs-add/remove' stamp: 'DMG 5/15/2011 21:36'!removeMorph: aMorph	"if a nested image morph has been removed, (possibly) recalculate displayed	 morphs size"	super removeMorph: aMorph.	nmorphs := nmorphs - 1.	self recalcImageSize.	! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/17/2011 21:45'!addCol	ncols := ncols + 1.	self recalcImageSize.		! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/17/2011 21:45'!addRow	nrows := nrows + 1.	self recalcImageSize.	! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/17/2011 21:46'!delCol	(ncols > 1) ifTrue: [ ncols := ncols - 1].	self recalcImageSize.! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/17/2011 21:46'!delRow	(nrows > 1) ifTrue: [ nrows := nrows - 1].	self recalcImageSize.! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/21/2011 22:51'!maximize	"set size to the maximum per PasteUpMorph available area, 	 strip will be removed"	| p |	p := World.	self stripOff .	mxmd := true.	self bounds: p innerBounds.! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/18/2011 22:44'!recalcImageSize	"if number of image morphs has changed, recalculate image size"	| v |	v := self height / nrows.	imgside := (v floor asInteger) - self cellInset.	self submorphsDo: [ :m |		(m respondsTo: #image) & (m respondsTo: #image: ) ifTrue: [			(m respondsTo: #pristine) ifTrue: [ m pristine ].			m image: (m image scaledToSize: imgside@imgside).		].	].	ncols := (self width / (imgside + self cellInset)) floor max: 1.	nrows := (self height / (imgside + self cellInset)) floor max: 1.	self changed.	! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/15/2011 23:28'!resizeMorph: evt	super resizeMorph: evt.	self recalcImageSize.	self changed.! !!AACPanel methodsFor: 'geometry' stamp: 'DMG 5/21/2011 22:52'!restore	"restore size to last unmaximized saved, strip will be deleted"	self stripOff .	self bounds: svbnds.	mxmd := false.	self layoutChanged.! !!AACPanel methodsFor: 'layout' stamp: 'DMG 5/21/2011 23:25'!layoutChanged	| s |	super layoutChanged.	self recalcImageSize.	mxmd ifFalse: [		svbnds := self bounds copy.	].	s := AACStrip getStrip.	s ifNotNil: [		s width: self width.		s height: self height * 0.66.		s left: self left.		mxmd ifTrue: [			s top: World top.		] ifFalse: [			s bottom: self top.		].	].! !!AACPanel methodsFor: 'layout' stamp: 'DMG 5/21/2011 23:01'!stripOff	"remove the AAC strip from the screen if exists"	AACStrip getStrip ifNotNil: [ | b |		AACStrip getStrip delete.		b := self bottom.		self height: (self height) * 1.51.		self bottom: b.	].! !!AACPanel methodsFor: 'layout' stamp: 'DMG 5/21/2011 23:03'!stripOn	"display the story strip if not already exists"	AACStrip getStrip ifNil: [ | s b h |		b := self bottom.		h := self height.		self height: self height * 0.66.		self bottom: b.		s := AACStrip new openInWorld.		s width: self width.		s height: h / 3.		s left: self left.		mxmd ifTrue: [			s top: World top.		] ifFalse: [			s bottom: self top.		].	].! !!AACPanel methodsFor: 'initialization' stamp: 'DMG 5/19/2011 22:38'!initialize	super initialize.	locked := false.	panels := Dictionary new.	ptop := self.	up := self.	nmorphs := 0.	nrows := 1.	ncols := 1.	mxmd := false.	self 	bounds: (100@100 corner: 300@300) ;		 	layoutPolicy: TableLayout new ;			listDirection: #leftToRight ;			wrapCentering: #topLeft ;			listCentering: #center ;			vResizing: #rigid ;			hResizing: #rigid ;			rubberBandCells: true ;			cellSpacing: #globalSquare ;			wrapDirection: #leftToRight ;			color: Color lightGreen ;			cellInset: 5 ;			recalcImageSize ;			layoutChanged.	! !!AACPanel methodsFor: 'menu' stamp: 'DMG 5/21/2011 23:13'!addYellowButtonMenuItemsTo: aMenu event: evt 	"Populate aMenu with appropriate menu items for a  	yellow-button (context menu) click."	aMenu defaultTarget: self.	aMenu addTitle: ('rows: ', nrows, ' cols: ', ncols, ' pics: ', nmorphs).	(nmorphs < (ncols * nrows)) ifTrue: [		aMenu add: 'add a picture' translated action: #newMorph.	].	aMenu addLine.	aMenu add: ('increase #rows to ', (nrows + 1)) translated action: #addRow.	((nrows > 1) and: [ nmorphs <= ((nrows - 1) * (ncols - 1)) ]) ifTrue: [		aMenu add: ('decrease #rows to ', (nrows - 1)) translated action: #delRow.	].	aMenu addLine.	AACStrip getStrip ifNil: [		aMenu add: 'strip on' translated action: #stripOn.	] ifNotNil: [		aMenu add: 'strip off' translated action: #stripOff.	].	aMenu addLine.	mxmd ifTrue: [		aMenu add: 'restore' translated action: #restore.	] ifFalse: [		aMenu add: 'maximize' translated action: #maximize.	].	(nmorphs >= 1) ifTrue: [		aMenu addLine.		aMenu add: 'remove pictures' translated action: #removeAll.	].! !SystemWindow subclass: #AACStrip	instanceVariableNames: 'images imgspace ready'	classVariableNames: 'TheStrip'	poolDictionaries: ''	category: 'SimpleAAC'!!AACStrip methodsFor: 'dropping/grabbing' stamp: 'DmitryGolubovsky 1/22/2011 23:00'!acceptDroppingMorph: aMorph event: ev  "if the dropping morph is accepted it gets owned by the nested alignment morph (imgspace)"  imgspace addMorphBack: aMorph.  aMorph onStrip: true.  self updateStory.  SimpleAAC playing: nil.! !!AACStrip methodsFor: 'change reporting' stamp: 'DMG 2/2/2011 06:33'!changed	| istl isbr |	ready		ifTrue: [istl := labelArea fullBounds bottomLeft.			isbr := self bounds bottomRight.			imgspace				bounds: (istl corner: isbr).			self updateStory].	super changed! !!AACStrip methodsFor: 'change reporting' stamp: 'DmitryGolubovsky 1/22/2011 21:48'!updateStory  "if a picture is added or removed from the strip, update the title"  | story |  story := (imgspace submorphs collect: [ :m | m says ]) inject: '' into: [ :s :n | s, ' ', n.] .  (story allSatisfy: [:c | c = Character space ]) ifTrue: [ story := 'No story told yet'].  self setLabel: story.  SimpleAAC playing: nil.! !!AACStrip methodsFor: 'initialization' stamp: 'DMG 3/27/2011 21:56'!delete	"Once the Strip has been removed (closed) set the current strip to nil"	(AACStrip getStrip == self) ifTrue: [ AACStrip setStrip: nil ].	^ super delete.! !!AACStrip methodsFor: 'initialization' stamp: 'DMG 3/29/2011 05:18'!initialize	ready := false.	super initialize.	images := {}.	self setLabel: 'No story told yet'.	imgspace := AACImageSpace new.	self addMorph: imgspace after: labelArea.	ready := true.	AACStrip setStrip: self.	self changed.! !!AACStrip methodsFor: 'submorphs-add/remove' stamp: 'DMG 3/29/2011 06:18'!addAACMorph: aMorph	"if the morph is accepted it gets owned by the nested alignment morph (imgspace)	unless the image area width is insufficient in which case morph will be deleted"	aMorph ifNotNil: [		(aMorph respondsTo: #says) ifTrue: [			| wds |			wds := (aMorph width) + 					((imgspace submorphs) 	inject: 0 													into: [ :w :m | w + m width ]).			imgspace width > (wds * 1.1) ifTrue: [				imgspace addMorphBack: aMorph. 				aMorph onStrip: true.				self updateStory.				SimpleAAC playing: nil.			] ifFalse: [aMorph delete].		].	].! !!AACStrip methodsFor: 'event handling' stamp: 'DMG 3/24/2011 23:09'!handlesMouseDown: anEvent  "always handle mouse events"  ^ true.! !!AACStrip methodsFor: 'event handling' stamp: 'DMG 3/31/2011 06:36'!mouseDown: anEvent	"on mouse click, remove the last (rightmost) AAC morph 	from the image space when clicked inside the image space"	| ss |	super mouseDown: anEvent.	(imgspace containsPoint: anEvent position) ifTrue: [	ss := imgspace submorphs size.	ss > 0 ifTrue: [		(imgspace submorphs at: ss) delete.		self updateStory.		SimpleAAC playing: nil.			] ifFalse: [ AACStrip setStrip: self ]		]	! !!AACStrip methodsFor: 'submorphs-accessing' stamp: 'DMG 4/25/2011 22:34'!imgSpaceHeight	"comment stating purpose of message"	^imgspace height.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AACStrip class	instanceVariableNames: ''!!AACStrip class methodsFor: 'class variables' stamp: 'DMG 3/31/2011 22:43'!getStrip	"answer the currently set strip instance, if no strip instance set,	try to find all strips in the current project, and return the first	found"	| strips astrips |	strips := ((Project current world allMorphsAndBookPagesInto: Set new)			       select: [:m | m isKindOf: AACStrip]).	astrips := strips asArray.	TheStrip ifNotNil: [ (strips includes: TheStrip) ifTrue: [				^ TheStrip.			] ifFalse: [				TheStrip := nil.				^ self getStrip.			]		]				ifNil: [			astrips size > 0 ifTrue: [ 				TheStrip := astrips at: 1. 				^ TheStrip. 			] ifFalse: [ ^ nil ]		]! !!AACStrip class methodsFor: 'class variables' stamp: 'DMG 3/27/2011 21:56'!setStrip: aStrip	"sets an instance of a strip as current"	aStrip ifNotNil: [			(aStrip class name == #AACStrip) ifTrue: [					TheStrip := aStrip.				].		] ifNil: [ TheStrip := nil ].! !ImageMorph subclass: #FileImageMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!FileImageMorph methodsFor: 'other' stamp: 'DMG 4/28/2011 22:04'!imageFilesDirectory	^(FileDirectory default).! !!FileImageMorph methodsFor: 'other' stamp: 'DMG 5/19/2011 21:25'!replaceFromFileMenu	"replace own image with a new image selected from file menu"	| n |	n := self class 	fromFileMenuWithCaption: 'Replace' 						startingAt: self imageFilesDirectory.	n ifNotNil: [image := n image.].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileImageMorph class	instanceVariableNames: ''!!FileImageMorph class methodsFor: 'instance creation' stamp: 'DMG 4/28/2011 06:16'!fromFileMenuWithCaption: aString startingAt: aDirectory	"create an instance of mine selecting an image file from menu	 starting at given directory (not checked for existence)"	| m r |	m := StandardFileMenu 	oldFileMenu: aDirectory 									withPatternList: {'*.jpg'. '*.png'. '*.jpeg'. '*.gif'}.	r := m startUpWithCaption: aString at: ActiveHand position.	r ifNotNil: [ | f |		f := r directory pathName , r directory slash , r name.		^ (self fromImageFileNamed: f).	] ifNil: [ ^nil ]! !!FileImageMorph class methodsFor: 'instance creation' stamp: 'DMG 2/1/2011 21:28'!fromImageFileNamed: aFile 	"create from an external image file"	(self respondsTo: #withForm:)		ifTrue: [^ self				withForm: (ImageReadWriter formFromFileNamed: aFile)  "for Pharo"]		ifFalse: [^ self new				image: (Form fromFileNamed: aFile)  "for Squeak"]! !FileImageMorph subclass: #AACImageMorph	instanceVariableNames: 'category says onStrip pristine'	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/17/2011 00:08'!category  ^category.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/16/2011 23:36'!category: aSymbol  category := aSymbol.  self changed.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/21/2011 23:14'!onStrip  ^ onStrip.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/21/2011 23:14'!onStrip: aBool  onStrip := aBool.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DMG 5/19/2011 21:26'!pristine	pristine ifNotNil:  [self image: pristine copy].! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/17/2011 00:08'!says  ^says.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/16/2011 23:59'!says: aString  "specify that a spoken text is associated with this image"  (aString = '') ifTrue: [says := nil] ifFalse: [says := aString].  self changed.! !!AACImageMorph methodsFor: 'drawing' stamp: 'DMG 5/21/2011 23:12'!drawOn: aCanvas	"draw itself first, if says = true draw a speech icon, if opens a panel draw	 a folder contour"	super drawOn: aCanvas.	(self opensPanel) ifTrue: [		| xl xr xml xmr yb ytb ytt lcol xcoef ycoef step |		xcoef := 0.06.		ycoef := 0.06.		step := 0.02.		lcol := self defaultColor darker darker.		xl := self topLeft x + (self width * xcoef).		xr := self topRight x - (self width * xcoef).		yb := self bottomLeft y - (self height * ycoef).		ytb := self topLeft y + (self height * (xcoef + step)).		ytt := self topLeft y + (self height * (xcoef - step)).		xml := self topLeft x + (self width * (0.5 - step)).		xmr := self topLeft x + (self width * (0.5 + step)).		aCanvas drawPolygon: {xl@ytb. xml@ytb. xmr@ytt. xr@ytt. xr@yb. xl@yb. xl@ytb.}					color: (self defaultColor alpha: 0)					borderWidth: 2					borderColor: lcol.	].	(says isNil not and: [says size > 0] and: (self opensPanel not)) ifTrue: [ | i ns |		i := SimpleAAC iconSpeech copy.		ns := self height * 0.2.		aCanvas translucentImage: (i scaledToSize: ns@ns) 					at: self innerBounds origin	].! !!AACImageMorph methodsFor: 'event handling' stamp: 'DMG 3/23/2011 23:02'!handlesMouseDown: anEvent  "always handle mouse events"  ^ true.! !!AACImageMorph methodsFor: 'event handling' stamp: 'DMG 5/19/2011 06:31'!mouseDown: anEvent	"When not on the strip, create a copy of itself and attach it to the strip"	"When on the strip the phrase is to be pronounced if sound wrapper is available"	"On middle (yellow) click bring up a dialog to request the spoken phrase"	| st |	anEvent yellowButtonPressed ifTrue: [			self sayDialog.			(says = '#') ifTrue: [self delete].			(says = '@') ifTrue: [				says := ''.				self replaceFromFileMenu. ].			self changed.		].	st := AACStrip getStrip.	anEvent redButtonPressed ifTrue: [		onStrip			ifTrue: [SimpleAAC say: (self says) playing: self]			ifFalse: [				self opensPanel ifTrue: [					| pn |					pn := self panelName.					(owner respondsTo: #panel:) ifTrue: [						owner panel: pn.					].					^ true.				].				st ifNotNil: [						| cl sih |						cl := self veryDeepCopy.						sih := (st imgSpaceHeight) * 0.9.						cl image: (self image scaledToSize: sih@sih).						st addAACMorph: cl.					] ifNil: [ SimpleAAC say: (self says) playing: self ].				].		].! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 4/28/2011 22:03'!imageFilesDirectory	^(SimpleAAC imageFilesDirectory).! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 5/7/2011 22:56'!opensPanel	"answer true if this AACImageMorph opens another panel when clicked rather than	 makes some speech sound"	(says isNil or: [says size < 1]) ifFalse: [		^ (says at: 1) = (Character value: 62)	] ifTrue: [^ false].! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 5/7/2011 22:44'!panelName	"answer a panel name if this AACImageMorph opens a panel when clicked.	 otherwise returns the main string"	self opensPanel ifTrue: [^says copyFrom: 2 to: says size] ifFalse: [^'main'].! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 5/19/2011 21:15'!replaceFromFileMenu	"like super, but remember the current dimensions, and set the image to those	 dimensions. save the unscaled image as pristine"	| h w m |	h := self image height.	w := self image width.	m := h max: w.	super replaceFromFileMenu.	pristine := self image deepCopy.	self image: (self image scaledToSize: m@m).	! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 5/7/2011 22:23'!sayDialog	"bring up a form to configure the associated speech"	says := FillInTheBlankMorph 						request: 'Type what this picture says, tap <Accept>', 									Character cr,									'''>name'' to go to panel named ''name''',									Character cr, 									'Type ''#'' and tap <Accept> to delete',									Character cr, 									'Type ''@'' and tap <Accept> to change picture'						initialAnswer: says						centerAt: ActiveHand cursorPoint						inWorld: ActiveWorld						onCancelReturn: says.! !!AACImageMorph methodsFor: 'initialization' stamp: 'DMG 3/30/2011 22:03'!initialize  super initialize.  says := ''.  category := #''.  onStrip := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AACImageMorph class	instanceVariableNames: ''!!AACImageMorph class methodsFor: 'instance creation' stamp: 'DMG 4/28/2011 06:21'!fromFileMenuWithCaption: aString	"create an instance of mine from the file menu starting at	 the default images location"	^self 	fromFileMenuWithCaption: aString 			startingAt: (SimpleAAC imageFilesDirectory).! !Object subclass: #SimpleAAC	instanceVariableNames: ''	classVariableNames: 'ConfigMode Soundwrapper'	poolDictionaries: ''	category: 'SimpleAAC'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleAAC class	instanceVariableNames: ''!!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 5/5/2011 21:26'!configmode  "returns true if config mode is enabled"  ConfigMode isNil ifTrue: [ConfigMode := false. ^false]                            ifFalse: [^ConfigMode]! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 5/5/2011 21:26'!configmode: aBool  "set AAC configuration mode"  ConfigMode := aBool.! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 5/10/2011 05:16'!imageFilesDirectory	"answer the directory path where images for PECs are looked for"	(AndroidTTS inAndroid)		ifFalse: [ ^FileDirectory default. ]		ifTrue: [ ^FileDirectory default. ].		! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 5/5/2011 21:28'!soundWrapper	"answer the currently set sound wrapper unless running in Android"	(AndroidTTS inAndroid) 		ifTrue: [^AndroidSoundWrapper new]		ifFalse: [^Soundwrapper].	! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 5/5/2011 21:28'!soundWrapper: aWrapper  "set the sound wrapper"  Soundwrapper := aWrapper.! !!SimpleAAC class methodsFor: 'icons' stamp: 'DmitryGolubovsky 1/12/2011 23:15'!iconSpeech  "icon image to be placed on an AACImageMorph when spoken message is defined for this image"^(Form	extent: 32@32	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134217728 1107296256 1073741824 234881024 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3305111552 4278190080 4076863488 4227858432 4278190080 4009754624 2348810240 285212672 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 150994944 1291845632 2902458368 4278190080 2214592512 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 452984832 3774873600 3053453312 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 3791650816 1879048192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 536870912 4278190080 0 0 0 0 0 0 0 0 1610612736 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 3556769792 1006632960 0 0 0 0 0 0 2164260864 1224736768 1811939328 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 2952790016 1224736768 0 0 0 0 3019898880 2399141888 0 2382364672 2818572288 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 3556769792 671088640 0 654311424 2449473536 0 2936012800 1493172224 754974720 2919235584 2097152000 201326592 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4076863488 318767104 0 2365587456 1459617792 1207959552 1543503872 1073741824 2600468480 2046820352 1342177280 1610612736 0 0 0 0 0 0 0 0 0 0 4076863488 0 0 0 0 0 0 0 0 0 2382364672 2801795072 0 352321536 2214592512 2684354560 0 2550136832 2634022912 838860800 1358954496 2566914048 0 0 0 0 0 0 0 0 0 0 3825205248 0 0 0 0 0 0 0 0 0 0 3674210304 1056964608 0 2701131776 2566914048 0 2650800128 2550136832 100663296 1996488704 2785017856 0 0 0 0 0 0 0 0 0 0 3573547008 0 0 0 0 0 0 0 0 0 637534208 1895825408 2365587456 0 2969567232 2701131776 0 3019898880 2852126720 0 2516582400 3036676096 0 0 0 0 0 0 0 0 0 0 3321888768 0 0 0 0 0 0 0 0 369098752 3976200192 2667577344 536870912 0 3556769792 3456106496 0 3523215360 3388997632 100663296 2818572288 3388997632 0 0 0 0 0 0 0 0 0 0 3087007744 0 0 0 0 0 0 0 2449473536 3137339392 2902458368 0 0 0 4127195136 3875536896 0 4278190080 3305111552 587202560 3321888768 3170893824 0 0 0 0 0 0 0 0 0 0 2885681152 0 0 0 0 0 0 0 3120562176 1979711488 0 0 0 1342177280 3791650816 3187671040 721420288 4278190080 2634022912 1409286144 3674210304 2650800128 0 0 0 0 0 0 0 0 0 0 2717908992 0 0 0 0 0 0 0 0 2432696320 1291845632 0 0 3372220416 3254779904 1811939328 2063597568 4278190080 1560281088 2483027968 3841982464 1795162112 0 0 0 0 0 0 0 0 0 0 2634022912 0 0 0 0 0 0 0 0 3120562176 0 0 905969664 3724541952 4076863488 0 3690987520 4278190080 0 3892314112 3875536896 704643072 0 0 0 0 0 0 0 0 0 0 2634022912 0 0 0 0 1006632960 1191182336 134217728 452984832 1677721600 0 0 3422552064 4076863488 2751463424 989855744 4278190080 3170893824 721420288 3539992576 4177526784 0 0 0 0 0 0 0 0 0 0 0 2600468480 0 0 0 0 2566914048 671088640 2147483648 2919235584 251658240 0 0 754974720 3707764736 721420288 4143972352 4278190080 872415232 3774873600 2533359616 2516582400 0 0 0 0 0 0 0 0 0 0 0 2566914048 0 0 0 0 2415919104 0 0 0 0 0 0 0 0 2617245696 4278190080 3724541952 1644167168 2986344448 3976200192 503316480 0 0 0 0 0 0 0 0 0 0 0 2113929216 2248146944 2097152000 1962934272 1811939328 2214592512 0 0 0 0 0 0 0 0 0 2264924160 721420288 4278190080 2852126720 3154116608 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1073741824 4278190080 4278190080 369098752 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1342177280 1006632960 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!SimpleAAC class methodsFor: 'utility' stamp: 'DmitryGolubovsky 1/12/2011 22:07'!imgStream: aFile  "invoke this method to obtain a stream from am external image file"  | image stream |  image := ColorForm fromFileNamed: aFile.  stream := WriteStream with: String new.  image storeOn: stream.  ^stream contents.! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/22/2011 21:48'!playing: aHash  "specify a hash for the sound wrapper to identify the last played phrase. can be used to set the hash   to nil so the sound wrapper can repeat whatever it played"   | s |	  s := SimpleAAC soundWrapper.	  (s notNil) ifTrue:  [ s playing: aHash.].! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/21/2011 05:32'!say: aPhrase  "pronounce the phrase given if sound wrapper is configured, with default voice. the phrase may be   repeated (no hash will be stored in the sound wrapper"  SimpleAAC say: aPhrase playing: nil.! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DMG 3/27/2011 22:07'!say: aPhrase playing: aHash  "the most common way to invoke a speech syntesizer. if defined and configured, this method pronounces   the phrase given with the default voice. the hash will be stored in the sound wrapper, and thus the last   played whatever would not be repeated. if playing is nil then the phrase will be played anyway"  | s |	  s := SimpleAAC soundWrapper.	  (s notNil and: [aPhrase notNil]) ifTrue:  [  		aHash isNil | ((aHash == s playing) not) ifTrue: [			        s playing: aHash.   		              s say: aPhrase ]	].! !Object subclass: #SoundWrapper	instanceVariableNames: 'pgmPath libPath defaultVoice playing'	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/20/2011 22:06'!defaultVoice  "answer the default voice (may be nil)"  ^ defaultVoice.! !!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/21/2011 05:09'!defaultVoice: aSymbol  "set default voice: should be on the list of voices available"  | vs hasvoice |  vs := self listVoices.  hasvoice := vs anySatisfy: [ :s | s = aSymbol ].  hasvoice ifTrue: [defaultVoice := aSymbol]                ifFalse: [StandardWindow new alert: 'Voice ', aSymbol asString, ' is not available'].  ^self.! !!SoundWrapper methodsFor: 'configuration' stamp: 'DMG 2/3/2011 06:06'!libPath: aPath 	"specify path to the portaudio shared library"	libPath := aPath! !!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/18/2011 22:37'!pgmPath: aFile  "set the TTS program path for future reference"  pgmPath := aFile.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/18/2011 22:44'!listVoices  "answers a list of symbols each identifying a voice available"  ^ self subclassResponsibility.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/21/2011 00:06'!playing  ^playing.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/21/2011 00:11'!playing: aHash  "set playing to the hash of the image last played. this may help avoid repetitions of the same sound if    the same image is repeatedly clicked. use of this method is advisory."  playing := aHash.! !!SoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/20/2011 22:05'!say: aPhrase  "say the given phrase with default voice whatever it may be"  ^self say: aPhrase withVoice: defaultVoice.! !!SoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/20/2011 22:03'!say: aPhrase withVoice: aSymbol  "say the given phrase with specified voice. if the voice is not available, try the default voice.   if the default voice is not available either, use the external program default voice"  ^ self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundWrapper class	instanceVariableNames: ''!!SoundWrapper class methodsFor: 'instance creation' stamp: 'DmitryGolubovsky 1/18/2011 22:42'!withPgmOn: aFile  ^ self new pgmPath: aFile.! !SoundWrapper subclass: #AndroidSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AndroidSoundWrapper methodsFor: 'access' stamp: 'DMG 3/21/2011 22:22'!listVoices	"answer a list of voices available"	^(AndroidVoices class) allMethodsInCategory: #voices.! !!AndroidSoundWrapper methodsFor: 'speech synthesis' stamp: 'DMG 3/21/2011 22:48'!say: aPhrase withVoice: aSymbol  "say the given phrase with specified voice. if the voice is not available, try the default voice."	"AndroidVoices perform: aSymbol."	AndroidTTS speak: aPhrase.! !!AndroidSoundWrapper methodsFor: 'configuration' stamp: 'DMG 3/21/2011 22:25'!defaultVoice	"answers the default voice"	^#default.! !SoundWrapper subclass: #EspeakSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!EspeakSoundWrapper methodsFor: 'access' stamp: 'DMG 2/3/2011 06:26'!listVoices	"Invoke speak --voices=en and read back whatever it outputs, pick	the 4th column, 	drop the first token. 	Expected message format is <whatever> : space-separated-list"	| lp cmd out outsplit |	libPath		ifNil: [lp := '']		ifNotNil: [lp := libPath].	cmd := 'LD_LIBRARY_PATH=' , lp , ' ' , pgmPath , ' --voices=en | awk ''{print $4}'' '.	out := (PipeableOSProcess command: cmd) output.	"split into lines, then drop the first one"	outsplit := ((out subStrings: {Character lf})				copyWithout: 'VoiceName')				collect: [:s | s asSymbol].	^ outsplit! !!EspeakSoundWrapper methodsFor: 'speech synthesis' stamp: 'DMG 2/3/2011 06:35'!say: aPhrase withVoice: aVoice 	"invoke the external speak program to say the phrase specified with	the voice specified.	if the voice is nil then run speak without the voice option. Answer with	whatever the external	speak program outputs, and returns only after the program completes"	| lp voiceopt cmd out |	libPath		ifNil: [lp := '']		ifNotNil: [lp := libPath].	aVoice		ifNil: [voiceopt := '']		ifNotNil: [voiceopt := '-v ' , aVoice asString].	cmd := 'LD_LIBRARY_PATH=' , lp , ' ' , pgmPath , ' ' , voiceopt , ' "' , aPhrase , '"'.	out := (PipeableOSProcess command: cmd) output.	^ out! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EspeakSoundWrapper class	instanceVariableNames: ''!!EspeakSoundWrapper class methodsFor: 'instance creation' stamp: 'DMG 2/3/2011 05:28'!withPgmOn: aFile withLibraryOn: aLib	"create my instance with program and shared library locations specified"	^self new pgmPath: aFile ;	libPath: aLib.! !SoundWrapper subclass: #FliteSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!FliteSoundWrapper methodsFor: 'access' stamp: 'DMG 2/1/2011 21:53'!listVoices	"Invoke flite -lv and read back whatever it outputs. 	Expected message format is <whatever> : space-separated-list"	| out outsplit |	out := (PipeableOSProcess command: pgmPath , ' -lv') output.	"split at the position of colon. add a fake one so if the output does	not have a colon, an empty string	is returned rather than an error"	(out respondsTo: #splitOn:)		ifTrue: [outsplit := out , ':' splitOn: ':'			"for Pharo"]		ifFalse: [outsplit := out , ':' splitBy: ':'"for Squeak"].		^ (((outsplit at: 2)		subStrings: ' ')		select: [:s | (s = Character lf asString) not])		collect: [:s | s asSymbol]! !!FliteSoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/21/2011 00:09'!say: aPhrase withVoice: aVoice  "invoke the external flite program to say the phrase specified with the voice specified.   if the voice is nil then run flite without the voice option. Answer with whatever the external   flite program outputs, and returns only after the program completes"  | voiceopt cmd out |  aVoice ifNotNil: [voiceopt := '-voice ', (aVoice asString)]             ifNil: [voiceopt := ''].  cmd := pgmPath, ' ', voiceopt, ' -t "', aPhrase, '"'.  out := (PipeableOSProcess command: cmd) output .  ^out.! !