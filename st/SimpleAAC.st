AlignmentMorph subclass: #AACImageSpace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AACImageSpace methodsFor: 'drawing' stamp: 'DMG 3/29/2011 20:50'!drawOn: aCanvas	"draw a leftwards triangle at my right side taking 10% of width"	| mdpx mdpy cxctr cxlx cxty cxrx cxby cxsz |	super drawOn: aCanvas.	mdpx := self bottomRight x - (self width * 0.1).	mdpy := self bottomRight y - (self height * 0.5).	cxsz := self width * 0.015.	cxctr := (mdpx + (cxsz * 4))@mdpy.	cxlx := cxctr x - cxsz.	cxty := cxctr y + cxsz.	cxrx := cxctr x + cxsz.	cxby := cxctr y - cxsz.	aCanvas drawPolygon: {self bottomRight. 									mdpx@mdpy. 									self topRight}				color: self defaultColor darker darker darker				borderWidth: 1				borderColor: Color gray.	aCanvas line: cxlx@cxty				to: cxrx@cxby				width: 4				color: self defaultColor.	aCanvas line: cxrx@cxty				to: cxlx@cxby				width: 4				color: self defaultColor.! !SystemWindow subclass: #AACStrip	instanceVariableNames: 'images imgspace ready'	classVariableNames: 'TheStrip'	poolDictionaries: ''	category: 'SimpleAAC'!!AACStrip methodsFor: 'dropping/grabbing' stamp: 'DmitryGolubovsky 1/22/2011 23:00'!acceptDroppingMorph: aMorph event: ev  "if the dropping morph is accepted it gets owned by the nested alignment morph (imgspace)"  imgspace addMorphBack: aMorph.  aMorph onStrip: true.  self updateStory.  SimpleAAC playing: nil.! !!AACStrip methodsFor: 'change reporting' stamp: 'DMG 2/2/2011 06:33'!changed	| istl isbr |	ready		ifTrue: [istl := labelArea fullBounds bottomLeft.			isbr := self bounds bottomRight.			imgspace				bounds: (istl corner: isbr).			self updateStory].	super changed! !!AACStrip methodsFor: 'change reporting' stamp: 'DmitryGolubovsky 1/22/2011 21:48'!updateStory  "if a picture is added or removed from the strip, update the title"  | story |  story := (imgspace submorphs collect: [ :m | m says ]) inject: '' into: [ :s :n | s, ' ', n.] .  (story allSatisfy: [:c | c = Character space ]) ifTrue: [ story := 'No story told yet'].  self setLabel: story.  SimpleAAC playing: nil.! !!AACStrip methodsFor: 'initialization' stamp: 'DMG 3/27/2011 21:56'!delete	"Once the Strip has been removed (closed) set the current strip to nil"	(AACStrip getStrip == self) ifTrue: [ AACStrip setStrip: nil ].	^ super delete.! !!AACStrip methodsFor: 'initialization' stamp: 'DMG 3/29/2011 05:18'!initialize	ready := false.	super initialize.	images := {}.	self setLabel: 'No story told yet'.	imgspace := AACImageSpace new.	self addMorph: imgspace after: labelArea.	ready := true.	AACStrip setStrip: self.	self changed.! !!AACStrip methodsFor: 'submorphs-add/remove' stamp: 'DMG 3/29/2011 06:18'!addAACMorph: aMorph	"if the morph is accepted it gets owned by the nested alignment morph (imgspace)	unless the image area width is insufficient in which case morph will be deleted"	aMorph ifNotNil: [		(aMorph respondsTo: #says) ifTrue: [			| wds |			wds := (aMorph width) + 					((imgspace submorphs) 	inject: 0 													into: [ :w :m | w + m width ]).			imgspace width > (wds * 1.1) ifTrue: [				imgspace addMorphBack: aMorph. 				aMorph onStrip: true.				self updateStory.				SimpleAAC playing: nil.			] ifFalse: [aMorph delete].		].	].! !!AACStrip methodsFor: 'event handling' stamp: 'DMG 3/24/2011 23:09'!handlesMouseDown: anEvent  "always handle mouse events"  ^ true.! !!AACStrip methodsFor: 'event handling' stamp: 'DMG 3/31/2011 06:36'!mouseDown: anEvent	"on mouse click, remove the last (rightmost) AAC morph 	from the image space when clicked inside the image space"	| ss |	super mouseDown: anEvent.	(imgspace containsPoint: anEvent position) ifTrue: [	ss := imgspace submorphs size.	ss > 0 ifTrue: [		(imgspace submorphs at: ss) delete.		self updateStory.		SimpleAAC playing: nil.			] ifFalse: [ AACStrip setStrip: self ]		]	! !!AACStrip methodsFor: 'submorphs-accessing' stamp: 'DMG 4/25/2011 22:34'!imgSpaceHeight	"comment stating purpose of message"	^imgspace height.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AACStrip class	instanceVariableNames: ''!!AACStrip class methodsFor: 'class variables' stamp: 'DMG 3/31/2011 22:43'!getStrip	"answer the currently set strip instance, if no strip instance set,	try to find all strips in the current project, and return the first	found"	| strips astrips |	strips := ((Project current world allMorphsAndBookPagesInto: Set new)			       select: [:m | m isKindOf: AACStrip]).	astrips := strips asArray.	TheStrip ifNotNil: [ (strips includes: TheStrip) ifTrue: [				^ TheStrip.			] ifFalse: [				TheStrip := nil.				^ self getStrip.			]		]				ifNil: [			astrips size > 0 ifTrue: [ 				TheStrip := astrips at: 1. 				^ TheStrip. 			] ifFalse: [ ^ nil ]		]! !!AACStrip class methodsFor: 'class variables' stamp: 'DMG 3/27/2011 21:56'!setStrip: aStrip	"sets an instance of a strip as current"	aStrip ifNotNil: [			(aStrip class name == #AACStrip) ifTrue: [					TheStrip := aStrip.				].		] ifNil: [ TheStrip := nil ].! !ImageMorph subclass: #FileImageMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!FileImageMorph methodsFor: 'other' stamp: 'DMG 4/28/2011 22:04'!imageFilesDirectory	^(FileDirectory default).! !!FileImageMorph methodsFor: 'other' stamp: 'DMG 4/28/2011 22:58'!replaceFromFileMenu	"replace own image with a new image selected from file menu"	| n |	n := self class 	fromFileMenuWithCaption: 'Replace' 						startingAt: self imageFilesDirectory.	n ifNotNil: [self image: n image].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileImageMorph class	instanceVariableNames: ''!!FileImageMorph class methodsFor: 'instance creation' stamp: 'DMG 4/28/2011 06:16'!fromFileMenuWithCaption: aString startingAt: aDirectory	"create an instance of mine selecting an image file from menu	 starting at given directory (not checked for existence)"	| m r |	m := StandardFileMenu 	oldFileMenu: aDirectory 									withPatternList: {'*.jpg'. '*.png'. '*.jpeg'. '*.gif'}.	r := m startUpWithCaption: aString at: ActiveHand position.	r ifNotNil: [ | f |		f := r directory pathName , r directory slash , r name.		^ (self fromImageFileNamed: f).	] ifNil: [ ^nil ]! !!FileImageMorph class methodsFor: 'instance creation' stamp: 'DMG 2/1/2011 21:28'!fromImageFileNamed: aFile 	"create from an external image file"	(self respondsTo: #withForm:)		ifTrue: [^ self				withForm: (ImageReadWriter formFromFileNamed: aFile)  "for Pharo"]		ifFalse: [^ self new				image: (Form fromFileNamed: aFile)  "for Squeak"]! !FileImageMorph subclass: #AACImageMorph	instanceVariableNames: 'category says onStrip'	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/17/2011 00:08'!category  ^category.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/16/2011 23:36'!category: aSymbol  category := aSymbol.  self changed.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/21/2011 23:14'!onStrip  ^ onStrip.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/21/2011 23:14'!onStrip: aBool  onStrip := aBool.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/17/2011 00:08'!says  ^says.! !!AACImageMorph methodsFor: 'accessing' stamp: 'DmitryGolubovsky 1/16/2011 23:59'!says: aString  "specify that a spoken text is associated with this image"  (aString = '') ifTrue: [says := nil] ifFalse: [says := aString].  self changed.! !!AACImageMorph methodsFor: 'drawing' stamp: 'DMG 3/30/2011 21:52'!drawOn: aCanvas	"draw itself first, if says = true draw a speech icon"	super drawOn: aCanvas.	(says isNil not and: [says size > 0]) ifTrue: [		aCanvas translucentImage: (SimpleAAC iconSpeech) 					at: self innerBounds origin		].! !!AACImageMorph methodsFor: 'event handling' stamp: 'DMG 3/23/2011 23:02'!handlesMouseDown: anEvent  "always handle mouse events"  ^ true.! !!AACImageMorph methodsFor: 'event handling' stamp: 'DMG 4/28/2011 23:04'!mouseDown: anEvent	"When not on the strip, create a copy of itself and attach it to the strip"	"When on the strip the phrase is to be pronounced if sound wrapper is available"	"On middle (yellow) click bring up a dialog to request the spoken phrase"	| st |	anEvent yellowButtonPressed ifTrue: [			says := FillInTheBlankMorph 								request: 'Type what this picture says, press <Enter>' 								initialAnswer: says								centerAt: ActiveHand cursorPoint								inWorld: ActiveWorld								onCancelReturn: says.			(says = '#') ifTrue: [self delete].			(says = '@') ifTrue: [				says := ''.				self replaceFromFileMenu. ].			self changed.		].	st := AACStrip getStrip.	anEvent redButtonPressed ifTrue: [		onStrip			ifTrue: [SimpleAAC say: (self says) playing: self]			ifFalse: [				st ifNotNil: [						| cl sih |						cl := self veryDeepCopy.						sih := (st imgSpaceHeight) * 0.9.						cl image: (self image scaledToSize: sih@sih).						st addAACMorph: cl.					] ifNil: [ SimpleAAC say: (self says) playing: self ].				].		].! !!AACImageMorph methodsFor: 'other' stamp: 'DMG 4/28/2011 22:03'!imageFilesDirectory	^(SimpleAAC imageFilesDirectory).! !!AACImageMorph methodsFor: 'initialization' stamp: 'DMG 3/30/2011 22:03'!initialize  super initialize.  says := ''.  category := #''.  onStrip := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AACImageMorph class	instanceVariableNames: ''!!AACImageMorph class methodsFor: 'instance creation' stamp: 'DMG 4/28/2011 06:21'!fromFileMenuWithCaption: aString	"create an instance of mine from the file menu starting at	 the default images location"	^self 	fromFileMenuWithCaption: aString 			startingAt: (SimpleAAC imageFilesDirectory).! !Object subclass: #SimpleAAC	instanceVariableNames: ''	classVariableNames: 'configmode soundWrapper'	poolDictionaries: ''	category: 'SimpleAAC'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleAAC class	instanceVariableNames: ''!!SimpleAAC class methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/13/2011 21:11'!configmode  "returns true if config mode is enabled"  configmode isNil ifTrue: [configmode := false. ^false]                            ifFalse: [^configmode]! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/13/2011 21:12'!configmode: aBool  "set AAC configuration mode"  configmode := aBool.! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 4/28/2011 05:20'!imageFilesDirectory	"answer the directory path where images for PECs are looked for"	(AndroidTTS inAndroid)		ifFalse: [ ^FileDirectory default. ]		ifTrue: [ ^FileDirectory on: '/sdcard/Images' ].		! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DMG 3/21/2011 22:28'!soundWrapper	"answer the currently set sound wrapper unless running in Android"	(AndroidTTS inAndroid) 		ifTrue: [^AndroidSoundWrapper new]		ifFalse: [^soundWrapper].	! !!SimpleAAC class methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/20/2011 21:58'!soundWrapper: aWrapper  "set the sound wrapper"  soundWrapper := aWrapper.! !!SimpleAAC class methodsFor: 'icons' stamp: 'DmitryGolubovsky 1/12/2011 23:15'!iconSpeech  "icon image to be placed on an AACImageMorph when spoken message is defined for this image"^(Form	extent: 32@32	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 134217728 1107296256 1073741824 234881024 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3305111552 4278190080 4076863488 4227858432 4278190080 4009754624 2348810240 285212672 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 150994944 1291845632 2902458368 4278190080 2214592512 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 452984832 3774873600 3053453312 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 3791650816 1879048192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 536870912 4278190080 0 0 0 0 0 0 0 0 1610612736 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 3556769792 1006632960 0 0 0 0 0 0 2164260864 1224736768 1811939328 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 2952790016 1224736768 0 0 0 0 3019898880 2399141888 0 2382364672 2818572288 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 3556769792 671088640 0 654311424 2449473536 0 2936012800 1493172224 754974720 2919235584 2097152000 201326592 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4076863488 318767104 0 2365587456 1459617792 1207959552 1543503872 1073741824 2600468480 2046820352 1342177280 1610612736 0 0 0 0 0 0 0 0 0 0 4076863488 0 0 0 0 0 0 0 0 0 2382364672 2801795072 0 352321536 2214592512 2684354560 0 2550136832 2634022912 838860800 1358954496 2566914048 0 0 0 0 0 0 0 0 0 0 3825205248 0 0 0 0 0 0 0 0 0 0 3674210304 1056964608 0 2701131776 2566914048 0 2650800128 2550136832 100663296 1996488704 2785017856 0 0 0 0 0 0 0 0 0 0 3573547008 0 0 0 0 0 0 0 0 0 637534208 1895825408 2365587456 0 2969567232 2701131776 0 3019898880 2852126720 0 2516582400 3036676096 0 0 0 0 0 0 0 0 0 0 3321888768 0 0 0 0 0 0 0 0 369098752 3976200192 2667577344 536870912 0 3556769792 3456106496 0 3523215360 3388997632 100663296 2818572288 3388997632 0 0 0 0 0 0 0 0 0 0 3087007744 0 0 0 0 0 0 0 2449473536 3137339392 2902458368 0 0 0 4127195136 3875536896 0 4278190080 3305111552 587202560 3321888768 3170893824 0 0 0 0 0 0 0 0 0 0 2885681152 0 0 0 0 0 0 0 3120562176 1979711488 0 0 0 1342177280 3791650816 3187671040 721420288 4278190080 2634022912 1409286144 3674210304 2650800128 0 0 0 0 0 0 0 0 0 0 2717908992 0 0 0 0 0 0 0 0 2432696320 1291845632 0 0 3372220416 3254779904 1811939328 2063597568 4278190080 1560281088 2483027968 3841982464 1795162112 0 0 0 0 0 0 0 0 0 0 2634022912 0 0 0 0 0 0 0 0 3120562176 0 0 905969664 3724541952 4076863488 0 3690987520 4278190080 0 3892314112 3875536896 704643072 0 0 0 0 0 0 0 0 0 0 2634022912 0 0 0 0 1006632960 1191182336 134217728 452984832 1677721600 0 0 3422552064 4076863488 2751463424 989855744 4278190080 3170893824 721420288 3539992576 4177526784 0 0 0 0 0 0 0 0 0 0 0 2600468480 0 0 0 0 2566914048 671088640 2147483648 2919235584 251658240 0 0 754974720 3707764736 721420288 4143972352 4278190080 872415232 3774873600 2533359616 2516582400 0 0 0 0 0 0 0 0 0 0 0 2566914048 0 0 0 0 2415919104 0 0 0 0 0 0 0 0 2617245696 4278190080 3724541952 1644167168 2986344448 3976200192 503316480 0 0 0 0 0 0 0 0 0 0 0 2113929216 2248146944 2097152000 1962934272 1811939328 2214592512 0 0 0 0 0 0 0 0 0 2264924160 721420288 4278190080 2852126720 3154116608 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1073741824 4278190080 4278190080 369098752 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1342177280 1006632960 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!SimpleAAC class methodsFor: 'utility' stamp: 'DmitryGolubovsky 1/12/2011 22:07'!imgStream: aFile  "invoke this method to obtain a stream from am external image file"  | image stream |  image := ColorForm fromFileNamed: aFile.  stream := WriteStream with: String new.  image storeOn: stream.  ^stream contents.! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/22/2011 21:48'!playing: aHash  "specify a hash for the sound wrapper to identify the last played phrase. can be used to set the hash   to nil so the sound wrapper can repeat whatever it played"   | s |	  s := SimpleAAC soundWrapper.	  (s notNil) ifTrue:  [ s playing: aHash.].! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/21/2011 05:32'!say: aPhrase  "pronounce the phrase given if sound wrapper is configured, with default voice. the phrase may be   repeated (no hash will be stored in the sound wrapper"  SimpleAAC say: aPhrase playing: nil.! !!SimpleAAC class methodsFor: 'speech synthesis' stamp: 'DMG 3/27/2011 22:07'!say: aPhrase playing: aHash  "the most common way to invoke a speech syntesizer. if defined and configured, this method pronounces   the phrase given with the default voice. the hash will be stored in the sound wrapper, and thus the last   played whatever would not be repeated. if playing is nil then the phrase will be played anyway"  | s |	  s := SimpleAAC soundWrapper.	  (s notNil and: [aPhrase notNil]) ifTrue:  [  		aHash isNil | ((aHash == s playing) not) ifTrue: [			        s playing: aHash.   		              s say: aPhrase ]	].! !Object subclass: #SoundWrapper	instanceVariableNames: 'pgmPath libPath defaultVoice playing'	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/20/2011 22:06'!defaultVoice  "answer the default voice (may be nil)"  ^ defaultVoice.! !!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/21/2011 05:09'!defaultVoice: aSymbol  "set default voice: should be on the list of voices available"  | vs hasvoice |  vs := self listVoices.  hasvoice := vs anySatisfy: [ :s | s = aSymbol ].  hasvoice ifTrue: [defaultVoice := aSymbol]                ifFalse: [StandardWindow new alert: 'Voice ', aSymbol asString, ' is not available'].  ^self.! !!SoundWrapper methodsFor: 'configuration' stamp: 'DMG 2/3/2011 06:06'!libPath: aPath 	"specify path to the portaudio shared library"	libPath := aPath! !!SoundWrapper methodsFor: 'configuration' stamp: 'DmitryGolubovsky 1/18/2011 22:37'!pgmPath: aFile  "set the TTS program path for future reference"  pgmPath := aFile.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/18/2011 22:44'!listVoices  "answers a list of symbols each identifying a voice available"  ^ self subclassResponsibility.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/21/2011 00:06'!playing  ^playing.! !!SoundWrapper methodsFor: 'access' stamp: 'DmitryGolubovsky 1/21/2011 00:11'!playing: aHash  "set playing to the hash of the image last played. this may help avoid repetitions of the same sound if    the same image is repeatedly clicked. use of this method is advisory."  playing := aHash.! !!SoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/20/2011 22:05'!say: aPhrase  "say the given phrase with default voice whatever it may be"  ^self say: aPhrase withVoice: defaultVoice.! !!SoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/20/2011 22:03'!say: aPhrase withVoice: aSymbol  "say the given phrase with specified voice. if the voice is not available, try the default voice.   if the default voice is not available either, use the external program default voice"  ^ self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundWrapper class	instanceVariableNames: ''!!SoundWrapper class methodsFor: 'instance creation' stamp: 'DmitryGolubovsky 1/18/2011 22:42'!withPgmOn: aFile  ^ self new pgmPath: aFile.! !SoundWrapper subclass: #AndroidSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!AndroidSoundWrapper methodsFor: 'access' stamp: 'DMG 3/21/2011 22:22'!listVoices	"answer a list of voices available"	^(AndroidVoices class) allMethodsInCategory: #voices.! !!AndroidSoundWrapper methodsFor: 'speech synthesis' stamp: 'DMG 3/21/2011 22:48'!say: aPhrase withVoice: aSymbol  "say the given phrase with specified voice. if the voice is not available, try the default voice."	"AndroidVoices perform: aSymbol."	AndroidTTS speak: aPhrase.! !!AndroidSoundWrapper methodsFor: 'configuration' stamp: 'DMG 3/21/2011 22:25'!defaultVoice	"answers the default voice"	^#default.! !SoundWrapper subclass: #EspeakSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!EspeakSoundWrapper methodsFor: 'access' stamp: 'DMG 2/3/2011 06:26'!listVoices	"Invoke speak --voices=en and read back whatever it outputs, pick	the 4th column, 	drop the first token. 	Expected message format is <whatever> : space-separated-list"	| lp cmd out outsplit |	libPath		ifNil: [lp := '']		ifNotNil: [lp := libPath].	cmd := 'LD_LIBRARY_PATH=' , lp , ' ' , pgmPath , ' --voices=en | awk ''{print $4}'' '.	out := (PipeableOSProcess command: cmd) output.	"split into lines, then drop the first one"	outsplit := ((out subStrings: {Character lf})				copyWithout: 'VoiceName')				collect: [:s | s asSymbol].	^ outsplit! !!EspeakSoundWrapper methodsFor: 'speech synthesis' stamp: 'DMG 2/3/2011 06:35'!say: aPhrase withVoice: aVoice 	"invoke the external speak program to say the phrase specified with	the voice specified.	if the voice is nil then run speak without the voice option. Answer with	whatever the external	speak program outputs, and returns only after the program completes"	| lp voiceopt cmd out |	libPath		ifNil: [lp := '']		ifNotNil: [lp := libPath].	aVoice		ifNil: [voiceopt := '']		ifNotNil: [voiceopt := '-v ' , aVoice asString].	cmd := 'LD_LIBRARY_PATH=' , lp , ' ' , pgmPath , ' ' , voiceopt , ' "' , aPhrase , '"'.	out := (PipeableOSProcess command: cmd) output.	^ out! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EspeakSoundWrapper class	instanceVariableNames: ''!!EspeakSoundWrapper class methodsFor: 'instance creation' stamp: 'DMG 2/3/2011 05:28'!withPgmOn: aFile withLibraryOn: aLib	"create my instance with program and shared library locations specified"	^self new pgmPath: aFile ;	libPath: aLib.! !SoundWrapper subclass: #FliteSoundWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SimpleAAC'!!FliteSoundWrapper methodsFor: 'access' stamp: 'DMG 2/1/2011 21:53'!listVoices	"Invoke flite -lv and read back whatever it outputs. 	Expected message format is <whatever> : space-separated-list"	| out outsplit |	out := (PipeableOSProcess command: pgmPath , ' -lv') output.	"split at the position of colon. add a fake one so if the output does	not have a colon, an empty string	is returned rather than an error"	(out respondsTo: #splitOn:)		ifTrue: [outsplit := out , ':' splitOn: ':'			"for Pharo"]		ifFalse: [outsplit := out , ':' splitBy: ':'"for Squeak"].		^ (((outsplit at: 2)		subStrings: ' ')		select: [:s | (s = Character lf asString) not])		collect: [:s | s asSymbol]! !!FliteSoundWrapper methodsFor: 'speech synthesis' stamp: 'DmitryGolubovsky 1/21/2011 00:09'!say: aPhrase withVoice: aVoice  "invoke the external flite program to say the phrase specified with the voice specified.   if the voice is nil then run flite without the voice option. Answer with whatever the external   flite program outputs, and returns only after the program completes"  | voiceopt cmd out |  aVoice ifNotNil: [voiceopt := '-voice ', (aVoice asString)]             ifNil: [voiceopt := ''].  cmd := pgmPath, ' ', voiceopt, ' -t "', aPhrase, '"'.  out := (PipeableOSProcess command: cmd) output .  ^out.! !